webpackJsonp([24],[
/* 0 */
/***/ function(module, exports) {

	eval("//import $ from 'jquery'\n//import { search } from './lib/searchWikipedia'\n\n//const html = `\n//<div>\n//<h1>Wikipedia</h1>\n//<form id=\"form\">\n//<input id=\"input\" value=\"taco\"/>\n//<button type=\"submit\">Search</button>\n//</form>\n//<div id=\"loading\">Loading...</div>\n//<div id=\"meta\">\n//<p>Results for: <span id=\"title\"></span><p>\n//<p>\n//<label>\n//<input type=\"checkbox\" id=\"descending\">\n//Sort Descending\n//</label>\n//</p>\n//</div>\n//<ul id=\"results\"></ul>\n//</div>\n//`\n\n//$('#app').html(html) // <-- component\n\n//$('#form').on('submit', (event) => { // <-- state change\n//event.preventDefault()\n//const term = $('#input').val() // <-- state\n//$('#loading').show() // <-- time\n//$('#meta').hide() // <-- time\n//$('#results').empty() // <-- time\n//search(term, (err, results) => {\n//$('#loading').hide() // <-- time\n//$('#meta').show() // <-- time\n//$('#title').html(term) // <-- time\n//results.forEach((result) => {\n//const li = $('<li/>')\n//const html = `\n//<div>\n//${result.title}\n//<button>show more</button>\n//</div>\n//<div class=\"toggler\" style=\"display: none\">\n//<p>${result.description}</p>\n//</div>\n//`\n//li.html(html) // <-- time\n//if ($('#descending').is(':checked')) { // <-- state\n//li.prependTo($('#results')) // <-- time\n//} else {\n//li.appendTo($('#results')) // <-- time\n//}\n//li.find('button').on('click', () => { // <-- component\n//li.find('.toggler').toggle() // <-- time\n//const isHidden = li.find('.toggler').is(':hidden') // <-- state\n//li.find('button').html(isHidden ? 'show more' : 'hide') // <-- time\n//})\n//})\n//})\n//}).trigger('submit') // <-- state change\n\n//$('#descending').on('click', (event) => { // <-- state change\n//$('#results li').each((i, li) => {\n//$('#results').prepend(li) // <-- time\n//})\n//})\n\n// What's awesome:\n//\n// I can still bang out this code even after not using jQuery for\n// 4 years.\n//\n// What's not awesome:\n//\n// When our code...\n//\n// - is written as flows\n// - doesn't call out state\n// - has no entry point to change state\n//\n// ...it gets really hard to deal with. After you identify state,\n// and how to change it, you must write code to connect every state\n// to nearly every other state. Every feature requires changes to code\n// in multiple places. Also, it's just too hard to think about for must\n// of us leading to lot of bugs.\n\n\n////////////////////////////////////////////////////////////////////////////////\n//import Backbone from 'backbone'\n//import $ from 'jquery'\n//import _ from 'underscore'\n//import { search } from './lib/searchWikipedia'\n\n//const appTemplate = _.template(`\n//<div>\n//<h1><%= title %></h1>\n//<form id=\"form\">\n//<input id=\"input\" value=\"taco\"/>\n//<button type=\"submit\">Search</button>\n//</form>\n//<% if (loading) { %>\n//<div id=\"loading\">Loading...</div>\n//<% } else { %>\n//<div id=\"meta\">\n//<p>Results for: <span id=\"title\"><%= term %></span><p>\n//<p>\n//<label>\n//<input type=\"checkbox\" id=\"descending\" <%= descending ? 'checked' : '' %>>\n//Sort Descending\n//</label>\n//</p>\n//</div>\n//<% } %>\n//<ul id=\"results\">\n//<% results.forEach(function(result) { %>\n//<li class=\"toggleView\"></li>\n//<% }) %>\n//</ul>\n//</div>\n//`)\n\n\n//const AppView = Backbone.View.extend({\n\n//template: appTemplate,\n\n//events: { // <-- delegated state changes\n//'submit #form': 'handleSubmit',\n//'click #descending': 'handleDescending'\n//},\n\n//initialize() {\n//this.listenTo(this.model, 'all', this.render)\n//this.listenTo(this.model, 'change:term', this.search)\n//this.render()\n//this.search()\n//},\n\n//handleSubmit(event) {\n//event.preventDefault()\n//this.model.set('term', this.$el.find('#input').val()) // KVO Web\n//},\n\n//search() {\n//this.model.set({ // KVO web\n//loading: true,\n//results: [],\n//descending: false // cascading update!\n//})\n//search(this.model.get('term'), (err, results) => {\n//this.model.set({ // KVO web\n//loading: false,\n//results: results\n//})\n//})\n//},\n\n//handleDescending() {\n//this.model.set( // <-- KVO web\n//'descending',\n//!this.model.get('descending')\n//)\n//},\n\n//render() {\n//const state = this.model.toJSON()\n//if (state.descending)\n//state.results = state.results.slice(0).reverse()\n//this.$el.html(this.template(state)) // DOM Bomb!\n//this.$el.find('#results li').each((index, el) => {\n//new ToggleView({ // <-- imperative (re)composition!\n//el: el,\n//model: new Backbone.Model(state.results[index])\n//}).render()\n//})\n//}\n//})\n\n//const ToggleView = Backbone.View.extend({\n//template: _.template(`\n//<div>\n//<%= title %>\n//<button>show more</button>\n//</div>\n//<% if (isOpen) { %>\n//<div>\n//<p><%= description %></p>\n//</div>\n//<% } %>\n//`),\n\n//events: {\n//'click button': 'toggle'\n//},\n\n//initialize() {\n//this.model.set('isOpen', false, { silent: true }) // <-- model ownership?\n//this.listenTo(this.model, 'change:isOpen', this.render)\n//},\n\n//toggle() {\n//this.model.set('isOpen', !this.model.get('isOpen')) // <-- KVO web\n//},\n\n//render() {\n//this.$el.html(this.template(this.model.toJSON()))\n//}\n//})\n\n//new AppView({\n//el: '#app',\n//model: new Backbone.Model({\n//title: 'Wikipedia',\n//loading: false,\n//term: 'tacos',\n//descending: false,\n//results: []\n//})\n//})\n\n// What's awesome\n//\n// - Moved state to models so we can identify what state changes\n//   the app.\n// - Moved creating UI into templates, one step closer to being\n//   declarative\n//\n// What's not so awesome\n//\n// - DOM Bombs\n//   - kill focus for assistive devices\n//   - non-performant\n//\n// - KVO Web\n//   - can't predict what will happen if you change state\n//     > Events complect communication and flow of control.\n//     > ... their fundamental nature, ... is that upon an event\n//     > an arbitrary amount of other code is run\n//     > http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html\n//\n//   - leads to cascading updates\n//     - non-performant\n//     - to fix leads to knowing how your app changes over time intimately\n//\n// - imperative composition\n//   - non-performant\n//   - to fix\n//     - have to know how your app changes over time intimately\n//     - lots of code to manage instances\n//     - lots of mistakes\n\n////////////////////////////////////////////////////////////////////////////////\n//import angular from 'angular'\n//import { search } from './lib/searchWikipedia'\n\n//document.documentElement.setAttribute('ng-app', 'wikipedia')\n\n//document.getElementById('app').innerHTML = `\n//<div ng-controller=\"MainController as main\">\n//<h1>Wikipedia</h1>\n//<form ng-submit=\"main.handleSubmit()\">\n//<input ng-model=\"main.term\"/>\n//<button type=\"submit\">Search</button>\n//</form>\n//<div ng-if=\"main.loading\">Loading...</div>\n//<div>\n//<p>{{main.sortedResults().length}} results for: {{main.term}}<p>\n//<p>\n//<label>\n//<input\n//type=\"checkbox\"\n//ng-model=\"main.descending\"\n//>\n//Sort Descending\n//</label>\n//</p>\n//</div>\n//<ul id=\"results\">\n//<li ng-repeat=\"result in main.sortedResults() track by result.title\">\n//<toggler title=\"{{result.title}}\">\n//<p>{{result.description}}</p>\n//</toggler>\n//</li>\n//</ul>\n//</div>\n//`\n\n//const app = angular.module('wikipedia', [])\n\n//app.controller('MainController', function ($rootScope) {\n//const main = this\n//main.term = 'taco' // <-- shared state!\n//main.results = []\n//main.loading = false\n//main.descending = false\n\n//main.getFriends = () => {\n//return [ { name: 'Ryan' }, { name: 'Michael' } ]\n//}\n\n//main.handleSubmit = () => {\n//main.loading = true\n//search(main.term, (err, results) => {\n//main.results = results\n//main.loading = false\n//$rootScope.$digest() // <-- time!\n//})\n//}\n\n//main.sortedResults = () => {\n//return main.descending ?\n//main.results.slice(0).reverse() : main.results\n//}\n\n//main.handleSubmit()\n//})\n\n//app.directive('toggler', () => { // <-- Global!\n//return {\n//restrict: 'E', // WTH?\n//scope: {\n//title: '@' // WTH?\n//},\n//controller($scope) {\n//$scope.isOpen = false\n//$scope.toggle = () => {\n//$scope.isOpen = !$scope.isOpen\n//}\n//},\n//replace: true,\n//transclude: true, // WTH?\n//template: `\n//<div>\n//<div>\n//{{title}}\n//<button ng-click=\"toggle()\">show more</button>\n//</div>\n//<div ng-if=\"isOpen\" ng-transclude></div>\n//<div>\n//`\n//}\n//})\n\n// What's awesome\n//\n// - fully declarative templates\n// - declarative component composition\n//\n// What's not so awesome\n//\n// - directives and filters are globals\n// - have to think about time with $apply/$watch, etc.\n// - rendering assumptions require you to keep object identity\n//   and therefore think about time\n// - and the real kicker: shared mutable state\n//\n// > July 7, 2014\n// >\n// > Vojta brought up some points that we donâ€™t yet have plans to solve\n// > some problems we see in larger apps.  In particular, how developers\n// > can reason about data flow within an app.\n// >\n// > Key points: scope hierarchy is a huge pile of shared state that many\n// > components from the application because of two way data-binding it's\n// > not clear what how the data flows because it can flow in all\n// > directions (including from child components to parents) - this makes\n// > it hard to understand the app and understand of impact of model\n// > changes in one part of the app on another (seemingly unrelated) part\n// > of it.\n//   https://twitter.com/teozaurus/status/518071391959388160\n\"use strict\";\n\n//////////////////\n// WEBPACK FOOTER\n// ./subjects/HelloWorld/lecture.js\n// module id = 0\n// module chunks = 24\n//# sourceURL=webpack:///./subjects/HelloWorld/lecture.js?");

/***/ }
]);