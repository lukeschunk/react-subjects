webpackJsonp([29],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(70);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(103);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _createOscillator = __webpack_require__(327);\n\nvar _createOscillator2 = _interopRequireDefault(_createOscillator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar styles = {};\n\nstyles.theremin = {\n  height: 200,\n  width: 200,\n  fontSize: 10,\n  border: '1px solid',\n  cursor: 'crosshair',\n  margin: 10,\n  display: 'inline-block'\n};\n\nvar App = function (_React$Component) {\n  _inherits(App, _React$Component);\n\n  function App() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, App);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = App.__proto__ || Object.getPrototypeOf(App)).call.apply(_ref, [this].concat(args))), _this), _this.play = function () {\n      _this.oscillator.play();\n    }, _this.stop = function () {\n      _this.oscillator.stop();\n    }, _this.changeTone = function (event) {\n      var clientX = event.clientX,\n          clientY = event.clientY;\n\n      var _event$target$getBoun = event.target.getBoundingClientRect(),\n          top = _event$target$getBoun.top,\n          right = _event$target$getBoun.right,\n          bottom = _event$target$getBoun.bottom,\n          left = _event$target$getBoun.left;\n\n      var pitch = (clientX - left) / (right - left);\n      var volume = 1 - (clientY - top) / (bottom - top);\n\n      _this.oscillator.setPitchBend(pitch);\n      _this.oscillator.setVolume(volume);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(App, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.oscillator = (0, _createOscillator2.default)();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement(\n        'div',\n        null,\n        _react2.default.createElement(\n          'h1',\n          null,\n          'What does it mean to be declarative?'\n        ),\n        _react2.default.createElement('div', {\n          style: styles.theremin,\n          onMouseEnter: this.play,\n          onMouseLeave: this.stop,\n          onMouseMove: this.changeTone\n        })\n      );\n    }\n  }]);\n\n  return App;\n}(_react2.default.Component);\n\n_reactDom2.default.render(_react2.default.createElement(App, null), document.getElementById('app'));\n\n////////////////////////////////////////////////////////////////////////////////\n// Can't predict what the sound is going to be by looking at state or the render\n// method, but componentDidUpdate makes things a lot easier to think about.\n\n//class App extends React.Component {\n//  state = {\n//    isPlaying: false,\n//    pitch: 0,\n//    volume: 0\n//  }\n//\n//  componentDidMount() {\n//    this.oscillator = createOscillator()\n//  }\n//\n//  play = () => {\n//    this.setState({ isPlaying: true })\n//  }\n//\n//  stop = () => {\n//    this.setState({ isPlaying: false })\n//  }\n//\n//  changeTone = (event) => {\n//    const { clientX, clientY } = event\n//    const { top, right, bottom, left } = event.target.getBoundingClientRect()\n//    const pitch = (clientX - left) / (right - left)\n//    const volume = 1 - (clientY - top) / (bottom - top)\n//    this.setState({ pitch, volume })\n//  }\n//\n//  componentDidUpdate() {\n//    if (this.state.isPlaying) {\n//      this.oscillator.play()\n//    } else {\n//      this.oscillator.stop()\n//    }\n//\n//    this.oscillator.setPitchBend(this.state.pitch)\n//    this.oscillator.setVolume(this.state.volume)\n//  }\n//\n//  render() {\n//    return (\n//      <div>\n//        <h1>What does it mean to be declarative?</h1>\n//        <div\n//          style={styles.theremin}\n//          onMouseEnter={this.play}\n//          onMouseLeave={this.stop}\n//          onMouseMove={this.changeTone}\n//        />\n//      </div>\n//    )\n//  }\n//}\n//\n//ReactDOM.render(<App/>, document.getElementById('app'))\n\n////////////////////////////////////////////////////////////////////////////////\n// We can do even better and make this fully declarative for the <App>. Instead\n// of using this.oscillator (an imperative API), let's wrap that up into a\n// <Tone> component and control it declaratively.\n\n//class Tone extends React.Component {\n//  static propTypes = {\n//    isPlaying: PropTypes.bool.isRequired,\n//    pitch: PropTypes.number.isRequired,\n//    volume: PropTypes.number.isRequired\n//  }\n//\n//  componentDidMount() {\n//    this.oscillator = createOscillator()\n//    this.doImperativeWork()\n//  }\n//\n//  componentDidUpdate() {\n//    this.doImperativeWork()\n//  }\n//\n//  doImperativeWork() {\n//    if (this.props.isPlaying) {\n//      this.oscillator.play()\n//    } else {\n//      this.oscillator.stop()\n//    }\n//\n//    this.oscillator.setPitchBend(this.props.pitch)\n//    this.oscillator.setVolume(this.props.volume)\n//  }\n//\n//  render() {\n//    return null\n//  }\n//}\n//\n//class App extends React.Component {\n//  state = {\n//    isPlaying: false,\n//    pitch: 0.5,\n//    volume: 0.5\n//  }\n//\n//  play = () => {\n//    this.setState({ isPlaying: true })\n//  }\n//\n//  stop = () => {\n//    this.setState({ isPlaying: false })\n//  }\n//\n//  changeTone = (event) => {\n//    const { clientX, clientY } = event\n//    const { top, right, bottom, left } = event.target.getBoundingClientRect()\n//    const pitch = (clientX - left) / (right - left)\n//    const volume = 1 - (clientY - top) / (bottom - top)\n//    this.setState({ pitch, volume })\n//  }\n//\n//  render() {\n//    return (\n//      <div>\n//        <h1>What does it mean to be declarative?</h1>\n//        <div\n//          style={styles.theremin}\n//          onMouseEnter={this.play}\n//          onMouseLeave={this.stop}\n//          onMouseMove={this.changeTone}\n//        >\n//          <Tone {...this.state}/>\n//        </div>\n//      </div>\n//    )\n//  }\n//}\n//\n//ReactDOM.render(<App/>, document.getElementById('app'))\n\n////////////////////////////////////////////////////////////////////////////////\n// Pull out <Theremin> into its own component - you're most of the way there!\n\n////////////////////////////////////////////////////////////////////////////////\n// Add a <Tone waveType> prop that changes the type of sound wave that is\n// generated and render many of them.\n\n//const waveType = PropTypes.oneOf([\n// 'sine',\n// 'triangle',\n// 'square',\n// 'sawtooth'\n//])\n//\n//class Tone extends React.Component {\n//  static propTypes = {\n//    isPlaying: PropTypes.bool.isRequired,\n//    pitch: PropTypes.number.isRequired,\n//    volume: PropTypes.number.isRequired,\n//    waveType: waveType.isRequired\n//  }\n//\n//  static defaultProps = {\n//    waveType: 'sine'\n//  }\n//\n//  componentDidMount() {\n//    this.oscillator = createOscillator()\n//    this.doImperativeWork()\n//  }\n//\n//  componentDidUpdate() {\n//    this.doImperativeWork()\n//  }\n//\n//  doImperativeWork() {\n//    if (this.props.isPlaying) {\n//      this.oscillator.play()\n//    } else {\n//      this.oscillator.stop()\n//    }\n//\n//    this.oscillator.setPitchBend(this.props.pitch)\n//    this.oscillator.setVolume(this.props.volume)\n//    this.oscillator.setType(this.props.waveType)\n//  }\n//\n//  render() {\n//    return null\n//  }\n//}\n//\n//class Theremin extends React.Component {\n//  static propTypes = {\n//    type: waveType\n//  }\n//\n//  state = {\n//    isPlaying: false,\n//    pitch: 0,\n//    volume: 0\n//  }\n//\n//  play = () => {\n//    this.setState({ isPlaying: true })\n//  }\n//\n//  stop = () => {\n//    this.setState({ isPlaying: false })\n//  }\n//\n//  changeTone = (event) => {\n//    const { clientX, clientY } = event\n//    const { top, right, bottom, left } = event.target.getBoundingClientRect()\n//    const pitch = (clientX - left) / (right - left)\n//    const volume = 1 - (clientY - top) / (bottom - top)\n//    this.setState({ pitch, volume })\n//  }\n//\n//  render() {\n//    return (\n//      <div\n//        style={styles.theremin}\n//        onMouseEnter={this.play}\n//        onMouseLeave={this.stop}\n//        onMouseMove={this.changeTone}\n//      >\n//        <Tone {...this.state} waveType={this.props.type}/>\n//      </div>\n//    )\n//  }\n//}\n//\n//class App extends React.Component {\n//  render() {\n//    return (\n//      <div>\n//        <h1>What does it mean to be declarative?</h1>\n//        <Theremin/>\n//        <Theremin type=\"triangle\"/>\n//        <Theremin type=\"square\"/>\n//        <Theremin type=\"sawtooth\"/>\n//      </div>\n//    )\n//  }\n//}\n//\n//ReactDOM.render(<App/>, document.getElementById('app'))\n\n////////////////////////////////////////////////////////////////////////////////\n// When you isolate all imperative work into components then the application\n// using them can model their UI in a declarative, predictible way because\n// it renders based on a snapshot of state, time has been removed from the\n// equation.\n//\n// Additionally, when the components doing the imperative work do it all in\n// componentDidMount and componenDidUpdate, you even make the imperative\n// work predictable because it's based on a snapshot of state in time also.\n\n//////////////////\n// WEBPACK FOOTER\n// ./subjects/ImperativeToDeclarative/lecture.js\n// module id = 0\n// module chunks = 29\n//# sourceURL=webpack:///./subjects/ImperativeToDeclarative/lecture.js?");

/***/ },

/***/ 327:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(328);\n\nfunction Oscillator(audioContext) {\n  // TODO make more things not use this.\n  var oscillatorNode = audioContext.createOscillator();\n  oscillatorNode.start(0);\n\n  var gainNode = audioContext.createGain();\n  this.pitchBase = 50;\n  this.pitchBend = 0;\n  this.pitchRange = 2000;\n  this.volume = 0.5;\n  this.maxVolume = 1;\n  this.frequency = this.pitchBase;\n\n  var hasConnected = false;\n  var frequency = this.pitchBase;\n\n  this.play = function () {\n    oscillatorNode.connect(gainNode);\n    hasConnected = true;\n  };\n\n  this.stop = function () {\n    if (hasConnected) {\n      oscillatorNode.disconnect(gainNode);\n      hasConnected = false;\n    }\n  };\n\n  this.setType = function (type) {\n    oscillatorNode.type = type;\n  };\n\n  this.setPitchBend = function (v) {\n    this.pitchBend = v;\n    frequency = this.pitchBase + this.pitchBend * this.pitchRange;\n    oscillatorNode.frequency.value = frequency;\n    this.frequency = frequency;\n  };\n\n  this.setVolume = function (v) {\n    this.volume = this.maxVolume * v;\n    gainNode.gain.value = this.volume;\n  };\n\n  this.connect = function (output) {\n    gainNode.connect(output);\n  };\n\n  return this;\n}\n\nfunction createOscillator() {\n  var audioContext = new AudioContext();\n  var theremin = new Oscillator(audioContext);\n\n  theremin.connect(audioContext.destination);\n\n  return theremin;\n}\n\nexports.default = createOscillator;\n\n//////////////////\n// WEBPACK FOOTER\n// ./subjects/ImperativeToDeclarative/utils/createOscillator.js\n// module id = 327\n// module chunks = 29\n//# sourceURL=webpack:///./subjects/ImperativeToDeclarative/utils/createOscillator.js?");

/***/ },

/***/ 328:
/***/ function(module, exports) {

	eval("'use strict';\n\n/* Copyright 2013 Chris Wilson\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n/* \n\nThis monkeypatch library is intended to be included in projects that are\nwritten to the proper AudioContext spec (instead of webkitAudioContext), \nand that use the new naming and proper bits of the Web Audio API (e.g. \nusing BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may\nhave to run on systems that only support the deprecated bits.\n\nThis library should be harmless to include if the browser supports \nunprefixed \"AudioContext\", and/or if it supports the new names.  \n\nThe patches this library handles:\nif window.AudioContext is unsupported, it will be aliased to webkitAudioContext().\nif AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or\nnoteGrainOn(), depending on parameters.\n\nThe following aliases only take effect if the new names are not already in place:\n\nAudioBufferSourceNode.stop() is aliased to noteOff()\nAudioContext.createGain() is aliased to createGainNode()\nAudioContext.createDelay() is aliased to createDelayNode()\nAudioContext.createScriptProcessor() is aliased to createJavaScriptNode()\nOscillatorNode.start() is aliased to noteOn()\nOscillatorNode.stop() is aliased to noteOff()\nAudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()\n\nThis library does NOT patch the enumerated type changes, as it is \nrecommended in the specification that implementations support both integer\nand string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel \nBiquadFilterNode.type and OscillatorNode.type.\n\n*/\n(function (global, exports, perf) {\n  'use strict';\n\n  function fixSetTarget(param) {\n    if (!param) // if NYI, just return\n      return;\n    if (!param.setTargetAtTime) param.setTargetAtTime = param.setTargetValueAtTime;\n  }\n\n  if (window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext')) {\n    window.AudioContext = webkitAudioContext;\n\n    if (!AudioContext.prototype.hasOwnProperty('createGain')) AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n    if (!AudioContext.prototype.hasOwnProperty('createDelay')) AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor')) AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;\n\n    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;\n    AudioContext.prototype.createGain = function () {\n      var node = this.internal_createGain();\n      fixSetTarget(node.gain);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;\n    AudioContext.prototype.createDelay = function () {\n      var node = this.internal_createDelay();\n      fixSetTarget(node.delayTime);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;\n    AudioContext.prototype.createBufferSource = function () {\n      var node = this.internal_createBufferSource();\n      if (!node.start) {\n        node.start = function (when, offset, duration) {\n          if (offset || duration) this.noteGrainOn(when, offset, duration);else this.noteOn(when);\n        };\n      }\n      if (!node.stop) node.stop = node.noteoff;\n      fixSetTarget(node.playbackRate);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;\n    AudioContext.prototype.createDynamicsCompressor = function () {\n      var node = this.internal_createDynamicsCompressor();\n      fixSetTarget(node.threshold);\n      fixSetTarget(node.knee);\n      fixSetTarget(node.ratio);\n      fixSetTarget(node.reduction);\n      fixSetTarget(node.attack);\n      fixSetTarget(node.release);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;\n    AudioContext.prototype.createBiquadFilter = function () {\n      var node = this.internal_createBiquadFilter();\n      fixSetTarget(node.frequency);\n      fixSetTarget(node.detune);\n      fixSetTarget(node.Q);\n      fixSetTarget(node.gain);\n      return node;\n    };\n\n    if (AudioContext.prototype.hasOwnProperty('createOscillator')) {\n      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;\n      AudioContext.prototype.createOscillator = function () {\n        var node = this.internal_createOscillator();\n        if (!node.start) node.start = node.noteOn;\n        if (!node.stop) node.stop = node.noteOff;\n        fixSetTarget(node.frequency);\n        fixSetTarget(node.detune);\n        return node;\n      };\n    }\n  }\n})(window);\n\n//////////////////\n// WEBPACK FOOTER\n// ./subjects/ImperativeToDeclarative/utils/AudioContextMonkeyPatch.js\n// module id = 328\n// module chunks = 29\n//# sourceURL=webpack:///./subjects/ImperativeToDeclarative/utils/AudioContextMonkeyPatch.js?");

/***/ }

});